---
title: "Forecast for ORP"
output: html_notebook
---

### Time series analysis notebook  

- This notebook uses the Ottawa river pathway time series; we'll figure out how to model this and then
apply a common approach to all counters.  
- Ideally, we would like to find a method that can incorporate all the information we have available instead of using monthly averages, for example.
- We might like to know when or how often the bike lanes/paths might get very busy.
     
   
#### Goals     
    
Broadly speaking, we can do three things with an effective model of the time series...   
- **smoothing**: fix data in the past that may have been erroneously measured/timed.   
- **filtering**: is the current data reasonable; is the instrument broken?    
- **forecasting**: predict traffic levels in the future from available data.   

<br>

#### Bike counters data    

The data has an obvious seasonal trend due to Ottawa's climate; further, the path has been used as a xc-skiing trail in the winter for the past couple years. We aren't interested in the winter anyway, so perhaps we will just set anything after the first major snowfall as zero until early spring when counts appear normal.

The weekly trend is very strong in some counters and less so in others. ORP is not as clear as eg. Laurier/Metcalfe, as to what the seasonality of weekly traffic is, or what contribution this component has to the observed counts.

ORP has fairly decent looking data without anything overtly suspicious so we won't remove any of these but might try to explain them later through special-days analysis (holidays, events).


####



```{r message=FALSE, warning=FALSE, include=FALSE}
rm(list=ls())
library(tidyverse)
library(lubridate)
library(tsibble)
library(feasts)
library(forecast)
library(GGally)
library(zoo)
library(ggfortify)
library(patchwork)
library(ggrepel)
```

##### Load data

- Data I downloaded earlier and parsed into a time series data format called a *tsibble*
- Needed to fill any gaps for time series analysis with *forecast* package. (`fill_gaps()` function)

```{r message=FALSE, warning=FALSE}
bikes <- readRDS("./data/ottbike_counters.ts.RDS")
ORP <- bikes %>%
  filter(location == 'Ottawa River') %>%
  select(c(Date, count)) %>%
  as_tsibble(index=Date) %>%
  fill_gaps()
# str(ORP)
```

##### Time series visual summary
  
  - First step to trying to understand the temporal and seasonal nature of the bike counters time series

```{r}
### Graphical summary from `gg_tsdisplay(ORP)`
gg_tsdisplay(ORP) #+ scale_colour_viridis_c()

```

This shows us the time series. We see that it has a strong annual seasonal component. The autoregression shows large, position acf coefficients (season is longer than window). We also note the weekly seasonality in the acf plot's 'scalloped' shape.

    
We can see that the data set has many low counts around or equal to zero.  
Winter has nil traffic because the path is an xc ski trail. We're okay with that.    
    

    
##### Create differenced count variable and visualize time series


    
```{r message=FALSE, warning=FALSE}
ORP <- ORP %>%
  mutate(lag = lag(count,1),
         diff = count-lag)
a <- ggplot(ORP, aes(x=Date, y= diff)) + geom_line() + ggtitle("ORP differenced time series")
b <- ggplot(ORP, aes(x= diff)) + geom_histogram(bins = 100) + ggtitle("ORP differenced counts")
a/b
```



    
So we can see a fairly strong linear relationship between successive counts. This suggests that our model needs to incorporate this autoregression for accurate modeling.



##### Autocorrelation

We can take a closer look at the autocorrelation (ACF) of bike counts at ORP by visualizing the autocorrelation coefficients for all trailing lags to find the period length of the seasonality component. We can do partial autocorrelation too, where the effect of intermediate lag days are removed.


```{r message=FALSE, warning=FALSE}
## lag.max parameter doesn't work in this function??
a <- ACF(ORP, .vars = count, na.action = na.pass, lag.max=365) %>% 
  autoplot() + ggtitle("ACF counts")
b <- ACF(ORP, .vars = diff, na.action = na.pass, lag.max=365) %>% 
  autoplot() + ggtitle("ACF differences")
c <- PACF(ORP, .vars = count, na.action = na.pass, lag.max=366) %>% 
  autoplot() + ggtitle("PACF counts")
d <- PACF(ORP, .vars = diff, na.action = na.pass, lag.max=366) %>% 
  autoplot() + ggtitle("PACF differences")
(a + b) / (c + d)
```
Even after differencing once, we still have a lot of significant autocorrelations with lags. This means we can extract more information from the seasonality of the times series, beyond just autoregression effects.

What if we differenced again? (2nd derivative of count)



```{r}

a <- ACF(ORP, .vars = count, na.action = na.pass, lag.max=365) %>% 
  autoplot() 
b <- PACF(ORP, .vars = count, na.action = na.pass, lag.max=366) %>% 
  autoplot()

c <- ggplot(ORP, aes(x=lag, y=count, colour = diff)) + 
  geom_point(alpha=0.99, shape=1)+ geom_smooth(colour='black') + 
  scale_color_viridis_c(end=0.9) +
  labs(x = "Lagging count", y="Count",title = "ORP counter - lag plot (one day)") +
  theme(legend.position = "none")

c+(a/b)
```


We can see how closely counts on successive days are by plotting count against the previous count in the lag plot. The acf and ppacf are large and positive. There is much seasonality in the ORP time series.




#####  Differenced time series

We can run the same analysis to see if 'differencing' the data (ie. taking the derivative of count). We can ascertain whether the time series is made 'stationary' by differencing. 

Ultimately, we want to deconvolute the time series into seasonal + remainder components of the data; to do this, we need to remove any 'trend', which specifically refers to any longer term changes in the context of forecasting.
     

```{r}
a <- ACF(ORP, .vars = diff, na.action = na.pass, lag.max=365) %>% 
  autoplot() + ggtitle("ACF differences")

b <- PACF(ORP, .vars = diff, na.action = na.pass, lag.max=366) %>% 
  autoplot() + ggtitle("PACF differences")
a/b
```



##### Extracting features 

ACF features

```{r}

bikes <- readRDS("./data/ottbike_counters.ts.RDS")
f.acf <- bikes %>% fill_gaps() %>%
  features(count, feat_acf)

GGally::ggpairs(f.acf)

ggplot(f.acf, aes(y = season_acf1, x = acf1, colour = diff1_acf1)) +
  geom_point() + geom_text_repel(aes(label=location)) +
  labs(title = "First autocorrelation coefficients (acf1)",
       x = "undifferenced", y = "season acf1", color = "2nd order diff") + 
  scale_color_viridis_c(option="A", end=0.85, begin=0.1)

ggplot(f.acf, aes(y = diff1_acf1, x = acf1, colour = diff2_acf1)) +
  geom_point() + geom_text_repel(aes(label=location)) +
  labs(title = "First autocorrelation coefficients (acf1)",
       x = "undifferenced", y = "1st order diff", color = "2nd order diff") + 
  scale_color_viridis_c(option="A", end=0.85, begin=0.1)


ggplot(f.acf, aes(y = diff1_acf10, x = acf10, colour = diff2_acf10)) +
  geom_point() + geom_text_repel(aes(label=location)) +
  labs(title = "Sum of squares of first ten autocorrelation coefficients (acf10)",
       x = "undifferenced", y = "1st order diff", color = "2nd order diff") + 
  scale_color_viridis_c(option="A", end=0.85, begin=0.1)

# ggplot(f.acf, aes(y = acf10, x = acf1, colour = season_acf1)) + geom_point() + geom_text_repel(aes(label=location))
# ggplot(f.acf, aes(y = diff1_acf1, x = acf1, colour = diff2_acf1)) + geom_point() + geom_text_repel(aes(label=location))

```

From STL features, we can plot seasonal over trend strengths to see which series are more seasonal/trendy.   
For formulas: [https://otexts.com/fpp3/stlfeatures.html](https://otexts.com/fpp3/stlfeatures.html)


```{r}
library(ggrepel)
f.stl <- bikes %>%
  features(count, feat_stl)

GGally::ggpairs(f.stl)

ggplot(f.stl, aes(x=trend_strength, y=seasonal_strength_week, color= linearity)) + geom_point(size=1) +
  geom_text_repel(aes(label=location)) +
  scale_color_viridis_c(option="A", end=0.85, begin=0.1) +
  labs(title= "Bike counters time series decomposition features",
       x = "trend strength", y= "weekly season strength")

ggplot(f.stl, aes(x=linearity, y=curvature, color= log(spikiness))) +
  geom_point(size=1) +
  geom_text_repel(aes(label=location)) +
  scale_color_viridis_c(option="A", end=0.85, begin=0.1) +
  labs(title= "Bike counters time series decomposition features",
       x = "Linearity", y= "Curvature", color = 'Spikiness')

ggplot(f.stl, aes(x=seasonal_peak_week, y=seasonal_trough_week)) +
  geom_point(size=1) +
  geom_text_repel(aes(label=location)) +
  labs(title= "Bike counters time series decomposition features",
       x = "Peak", y= "Trough")

ggplot(f.stl, aes(x = stl_e_acf1, y = stl_e_acf10)) + geom_point() + geom_text_repel(aes(label=location))
```

STL gives other statistics about each time series: linearity, curvature, spikiness

-  spikiness measures the prevalence of spikes in the remainder component $R_t$ of the STL decomposition. It is the variance of the leave-one-out variances of $R_t$
-  linearity measures the linearity of the trend component of the STL decomposition. It is based on the coefficient of a linear regression applied to the trend component.
-  curvature measures the curvature of the trend component of the STL decomposition. It is based on the coefficient from an orthogonal quadratic regression applied to the trend component.

We can see which days of the week are the peak or trough days of the weekly cycle. This tells us about the weekly seasonality at each counter.

We can also get the acf1 and acf10 for the remainder component of the time series:

- stl_e_acf1 is the first autocorrelation coefficient of the remainder series.
- stl_e_acf10 is the sum of squares of the first ten autocorrelation coefficients of the remainder series.



#### PCA of all time series features available


```{r}
library(broom)
bikes_features <- bikes %>%
  filter(location != 'Portage') %>%
  features(count, feature_set(pkgs='feasts'))

# remove all columns with NA's?
pcs <- bikes_features %>%
  select(-c(1)) %>%
  select_if(~ !any(is.na(.))) %>%
  mutate_if(is.integer, as.numeric) %>%
  select(-as.numeric(which(apply(bikes_features, 2, var)==0))) %>%
  select(-c(pp_pvalue, bp_pvalue)) %>%
  prcomp(scale=TRUE, na.action = na.pass) %>%
  augment(bikes_features)

pcs %>%
  ggplot(aes(x=.fittedPC1, y=.fittedPC2)) +
  geom_point() +
  geom_text_repel(aes(label=location)) +
  theme(aspect.ratio=1) +
  labs(title= "Principle components analysis of Ottawa bike counters",
       subtitle = "calculated from 36 features of each time series ")

saveRDS(pcs, "./data/bikes_pca.RDS")
```




```{r}
# shannon <- bikes %>%
  # features(count, feat_spectral)

feat_spectral(orp)
```


### Decomposition

Comparing STL decomposition with default parameters with and without 'robust' setting for handling outliers

```{r}
### 

orp <- ORP %>%
  filter(!is.na(count)) %>%
  fill_gaps() %>%
  mutate(count = na.approx(count)) %>% as_tsibble()
orp %>% model(STL(count ~ season(window=13), robust=TRUE)) %>%
  components() %>% autoplot()
orp %>% model(STL(count ~ season(window=13), robust=FALSE)) %>%
  components() %>% autoplot()

```






## Some basic time-series models

```{r}
# make ORP into base R time series
orp.ts <- ts(ORP[,c(2)], start = c(2010,1,1), deltat = 1/365)
orp.diff <- diff(orp.ts)
```


##### seasonal naive model benchmark

```{r}
fit <- snaive(orp.ts)
summary(fit)
checkresiduals(fit)
```

 - Forecast method: Seasonal naive method
    
    Model Information:
    Call: snaive(y = orp.ts) 
    
    Residual sd: 899.0799 


##### with differenced data

```{r}
fit.d <- snaive(orp.diff)
summary(fit.d)
checkresiduals(fit.d)
```

Forecast method: Seasonal naive method
    
    Model Information:
    Call: snaive(y = orp.diff) 
    
    Residual sd: 978.7187 


##### ETS model

```{r}
fit.ets <- ets(orp.ts)
# summary(fit.ets)
checkresiduals(fit.ets)
```
ran with warning warning about lack of seasonality in model.. freq>24/year (max is bimonthly seasonality data!):
        
    Missing values encountered. Using longest contiguous portion of time seriesI can't handle data with frequency greater than 24. Seasonality will be ignored. Try stlf() if you need seasonal forecasts.ETS(A,N,N) 

    Call:
     ets(y = orp.ts) 
    
      Smoothing parameters:
        alpha = 0.2254 
    
      Initial states:
        l = 0.3923 
    
      sigma:  642.4627


Missing values encountered. Using longest contiguous portion of time seriesI can't handle data with frequency greater than 24. Seasonality will be ignored. Try stlf() if you need seasonal forecasts.ETS(A,N,N) 


  *  sigma:  642.4627 - same as residual s.d.


Still lots of autocorrelation to incorporate into the model? Weekly autocorrelation..?

- all the above methods can't handle daily data, we need stl

##### STL + ETS model

- provide insight into structure of time series patterns
"Forecasting Using Stl Objects
Forecasts of STL objects are obtained by applying a non-seasonal forecasting method to the seasonally adjusted data and re-seasonalizing using the last year of the seasonal component."


- Maximum likelihood/Kalman filter creates fit
- can inject priors on parameters (Bayesian framework)
- can be expressed in arima terms of ar and ma.



```{r}
fit.stl <- stlf(orp.ts)
summary(fit.stl)
checkresiduals(fit.stl)
```


  **sigma:  548.0649**




#### Notes

Arima doesn't work on daily data. It struggles with large datasets, runs out of memory eventually.
  
So not good if we want to keep daily data and use the weekly trend for predicting daily volume.

We could summarise by monthly totals are run auto.arima on that for fun to see next year for ORP...

```
fit.arima <- auto.arima(orp.ts, stepwise = TRUE, approximation = TRUE, trace = TRUE)
summary(fit.arima)
checkresiduals(fit.arima)
```


#### Time-aware diagnostics

Augmented Dickey-Fuller test for stationarity:
    Time series test for trend/seasonality
    Various hypotheses can be tested



```{r}
ljung_box(orp$count)
ljung_box(orp$diff)
box_pierce(orp$count)
box_pierce(orp$diff)
coef_hurst(orp$count)
coef_hurst(orp$diff)
```





### Structural Time Series

```{r}


```



## Stationarity
## Cross-validation?
## Look ahead

## Review Goals     
    
Broadly speaking, we can do three things with an effective model of the time series...   
- **smoothing**: fix data in the past that may have been erroneously measured/timed.   
  - there are some gaps in the counters data due to construction/instrument failure
  - we could further improve our models later by removing erroneous data and adding simulated data.
  - this has alredy been done for certain periods, we could compare our smoothing with the city's previous work and visualize.
- **filtering**: is the current data reasonable; is the instrument broken?   
  - this would be a step further;  could be done with realish-time updates from Laurier/Met.
- **forecasting**: predict traffic levels in the future from available data.   
  - possibly has the most or least value depending on the model accuracy.

<br>







